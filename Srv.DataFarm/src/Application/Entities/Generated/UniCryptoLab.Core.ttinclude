<#@ template language="C#" hostspecific="True" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core.dll" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="$(SolutionDir)/libs/MySql.Data.dll" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Data.Common" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Windows.Forms" #>
<#+


string ConnectionString = "";
string ProviderName = "";

string ConnectionStringName = "";
string Namespace = "";
string RepoName = "";
string ClassPrefix = "";
string ClassSuffix = "";
string SchemaName = null;
bool IncludeViews = false;
bool GenerateOperations = false;
bool GenerateCommon = false;
bool GeneratePocos = true;
bool GenerateFunction = false;
bool ExplicitColumns = true;
bool TrackModifiedColumns = false;
string[] ExcludePrefix = new string[] {};
string[] IncludeTables = new string[] {};
string[] ClassReplaces = new string[] {};
Dictionary<string, string> EnumLists = new Dictionary<string, string> {};
List<Tuple<string,string,bool,string,string,string>> ReferenceLists = new List<Tuple<string,string,bool,string,string,string>>{};





public class Table
{
    public List<Column> Columns;	
    public string Name;
	public string Schema;
	public bool IsView;
    public string CleanName;
    public string ClassName;
	public string SequenceName;
	public bool Ignore;

    public Column PK
    {
        get
        {
            return this.Columns.SingleOrDefault(x=>x.IsPK);
        }
    }

	public Column GetColumn(string columnName)
	{
		return Columns.Single(x=>string.Compare(x.Name, columnName, true)==0);
	}

	public Column this[string columnName]
	{
		get
		{
			return GetColumn(columnName);
		}
	}

}

public class Column
{
    public string Name;
    public string PropertyName;
    public string PropertyType;
	public string Remark;
    public bool IsPK;
    public bool IsNullable;
	public bool IsAutoIncrement;
	public bool Ignore;

	public string DBType;
	public string DBDefault;
}

public class Tables : List<Table>
{
	public Tables()
	{
	}
	
	public Table GetTable(string tableName)
	{
		return this.Single(x=>string.Compare(x.Name, tableName, true)==0);
	}

	public Table this[string tableName]
	{
		get
		{
			return GetTable(tableName);
		}
	}

}


static Regex rxCleanUp = new Regex(@"[^\w\d_]", RegexOptions.Compiled);

static string[] cs_keywords = { "abstract", "event", "new", "struct", "as", "explicit", "null", 
	 "switch", "base", "extern", "object", "this", "bool", "false", "operator", "throw", 
	 "break", "finally", "out", "true", "byte", "fixed", "override", "try", "case", "float", 
	 "params", "typeof", "catch", "for", "private", "uint", "char", "foreach", "protected", 
	 "ulong", "checked", "goto", "public", "unchecked", "class", "if", "readonly", "unsafe", 
	 "const", "implicit", "ref", "ushort", "continue", "in", "return", "using", "decimal", 
	 "int", "sbyte", "virtual", "default", "interface", "sealed", "volatile", "delegate", 
	 "internal", "short", "void", "do", "is", "sizeof", "while", "double", "lock", 
	 "stackalloc", "else", "long", "static", "enum", "namespace", "string" };

static Func<string, string> CleanUp = (str) =>
{
	str = rxCleanUp.Replace(str, "_");

	if (char.IsDigit(str[0]) || cs_keywords.Contains(str))
		str = "@" + str;
	
    return str;
};

string CheckNullable(Column col)
{
    string result="";
    if(col.IsNullable && 
		col.PropertyType !="byte[]" && 
		col.PropertyType !="string" &&
		col.PropertyType !="Microsoft.SqlServer.Types.SqlGeography" &&
		col.PropertyType !="Microsoft.SqlServer.Types.SqlGeometry"
		)
        result="?";
    return result;
}

string CheckEnumType(Table tbl, Column col)
{
	foreach(var d in EnumLists){
		if(d.Key.Equals(tbl.ClassName + "." +col.PropertyName, StringComparison.CurrentCultureIgnoreCase)){
			return d.Value;		
		}
	}
	return col.PropertyType;
}
string GetRemark(Column col){
	if(!string.IsNullOrEmpty(col.Remark))
		return col.Remark;
	return col.PropertyName;
}

void Demo()
{
    WriteLine("// This file was automatically generated by the PetaPoco T4 Template");
    WriteLine("// Do not make changes directly to this file - edit the template instead");
    WriteLine("// ");
}
Tables LoadTables()
{
    WriteLine("// This file was automatically generated by the PetaPoco T4 Template");
	WriteLine("// Do not make changes directly to this file - edit the template instead");
	WriteLine("// ");
	WriteLine("// The following connection settings were used to generate this file");
	WriteLine("// ");
	WriteLine("//     Connection String :     `{0}`", ConnectionString);
	WriteLine("//     Provider:               `{0}`", ProviderName);
	WriteLine("//     Schema:                 `{0}`", SchemaName);
	WriteLine("//     Include Views:          `{0}`", IncludeViews);
    WriteLine("//     Include Tables:          `{0}`", IncludeTables.Length>0);

	try
	{
		Tables result;
		using(var conn=MySql.Data.MySqlClient.MySqlClientFactory.Instance.CreateConnection())
		{
			conn.ConnectionString=ConnectionString;         
			conn.Open();
        
			SchemaReader reader=new MySqlSchemaReader();
            
			reader.outer=this;
			result=reader.ReadSchema(conn);

			bool useInclude = IncludeTables.Length>0;

			// Remove unrequired tables/views
			for (int i=result.Count-1; i>=0; i--)
			{
				if (SchemaName!=null && string.Compare(result[i].Schema, SchemaName, true)!=0)
				{
					result.RemoveAt(i);
					continue;
				}
				if (!IncludeViews && result[i].IsView)
				{
					result.RemoveAt(i);
					continue;
				}
				if(StartsWithAny(result[i].ClassName, ExcludePrefix)) {
					result.RemoveAt(i);
					continue;
				}

			}

			conn.Close();

			

			var rxClean = new Regex("^(Equals|GetHashCode|GetType|ToString|repo|Save|IsNew|Insert|Update|Delete|Exists|SingleOrDefault|Single|First|FirstOrDefault|Fetch|Page|Query)$");
			foreach (var t in result)
			{
				if(useInclude)
				{
					t.Ignore = !IncludeTables.Any(i =>  t.Name==i);
				}
				foreach(var r in ClassReplaces){
					t.ClassName = t.ClassName.Replace(r,"");
				}
				t.ClassName = ClassPrefix + t.ClassName + ClassSuffix;
				foreach (var c in t.Columns)
				{
					c.PropertyName = rxClean.Replace(c.PropertyName, "_$1");

					// Make sure property name doesn't clash with class name
					if (c.PropertyName == t.ClassName)
						c.PropertyName = "_" + c.PropertyName;
				}
			}

		    return result;
		}
	}
	catch (Exception x)
	{
		var error=x.Message.Replace("\r\n", "\n").Replace("\n", " ");
		Warning(string.Format("Failed to read database schema - {0}", error));
		WriteLine("");
		WriteLine("// -----------------------------------------------------------------------------------------");
		WriteLine("// Failed to read database schema - {0}", error);
		WriteLine("// -----------------------------------------------------------------------------------------");
		WriteLine("");
		return new Tables();
	}

        
}

bool StartsWithAny(string s, IEnumerable<string> items)
{
    if (s == null)
        return false;

    return items.Any(i => s.StartsWith(i));
}

abstract class SchemaReader
{
	public abstract Tables ReadSchema(DbConnection connection);
	//public GeneratedTextTransformation outer;
    public Object outer;
	public void WriteLine(string o)
	{
		//outer.WriteLine(o);
	}

}

class MySqlSchemaReader : SchemaReader
{
	// SchemaReader.ReadSchema
	public override Tables ReadSchema(DbConnection connection)
	{
		var result=new Tables();   
		var cmd=MySql.Data.MySqlClient.MySqlClientFactory.Instance.CreateCommand();
		cmd.Connection=connection;
		cmd.CommandText=TABLE_SQL;

		
		//pull the tables in a reader
		using(cmd)
		{
			using (var rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Table tbl=new Table();
					tbl.Name=rdr["TABLE_NAME"].ToString();
					tbl.Schema="";
					tbl.IsView=string.Compare(rdr["TABLE_TYPE"].ToString(), "View", true)==0;
					tbl.CleanName=CleanUp(tbl.Name);
					tbl.ClassName=tbl.CleanName;
					result.Add(tbl);
				}
			}
		}


        //this will return everything for the DB
        var schema  = connection.GetSchema("COLUMNS");

        //loop again - but this time pull by table name
        foreach (var item in result) 
        {
            item.Columns=new List<Column>();

            //pull the columns from the schema
            var columns = schema.Select("TABLE_NAME='" + item.Name + "'");
            foreach (var row in columns) 
            {
                Column col=new Column();
                col.Name=row["COLUMN_NAME"].ToString().Trim();
				col.Remark=row["COLUMN_COMMENT"].ToString();
                col.PropertyName=CleanUp(col.Name);
                col.PropertyType=GetPropertyType(row);
                col.IsNullable=row["IS_NULLABLE"].ToString()=="YES";
                col.IsPK=row["COLUMN_KEY"].ToString()=="PRI";
				col.IsAutoIncrement=row["extra"].ToString().ToLower().IndexOf("auto_increment")>=0;

				col.DBType = row["COLUMN_TYPE"].ToString();
				col.DBDefault = row["COLUMN_DEFAULT"].ToString();

                item.Columns.Add(col);
            }
        }
        
        return result;
	
	}

	static string GetPropertyType(DataRow row)
	{
		string columnType = row["COLUMN_TYPE"].ToString();
		bool bUnsigned = columnType.IndexOf("unsigned")>=0;
		string propType="string";
		switch (row["DATA_TYPE"].ToString()) 
		{
			case "bigint":
				propType= bUnsigned ? "ulong" : "long";
				break;
			case "int":
				propType= bUnsigned ? "uint" : "int";
				break;
			case "smallint":
				propType= bUnsigned ? "ushort" : "short";
				break;
			case "guid":
				propType=  "Guid";
				 break;
			case "smalldatetime":
			case "date":
			case "datetime":
			case "timestamp":
				propType=  "DateTime";
				  break;
			case "time":
				propType=  "TimeSpan";
				  break;
			case "float":
				propType="float";
				break;
			case "double":
				propType="double";
				break;
			case "numeric":
			case "smallmoney":
			case "decimal":
			case "money":
				propType=  "decimal";
				 break;
			case "bit":
			case "bool":
			case "boolean":
				propType=  "bool";
				break;
			case "tinyint":
				string temp = columnType.Substring(columnType.LastIndexOf('(') + 1);
				temp = temp.Remove(temp.IndexOf(')'));
				ulong maxLength = ulong.Parse(temp);
				propType = maxLength <= 3 ? "bool" : (bUnsigned ? "byte" : "sbyte");
				break;
			case "image":
			case "binary":
			case "blob":
			case "mediumblob":
			case "longblob":
			case "varbinary":
				propType=  "byte[]";
				 break;
				 
		}
		return propType;
	}

	const string TABLE_SQL=@"
			SELECT * 
			FROM information_schema.tables 
			WHERE (table_type='BASE TABLE' OR table_type='VIEW') AND TABLE_SCHEMA=DATABASE()
			";

}

#>